<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试题总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="###Redis五大基本数据类型1.字符串 2.列表List 3.集合Set 4.哈希Hash 5.Zset  ###mysql主从复制原理①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。 ②salve从库连接master主库，,Master有多少个slave就会创建多少个binlog dump线程。 ③当Master节点的binlog发生变化">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题总结">
<meta property="og:url" content="http://example.com/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="###Redis五大基本数据类型1.字符串 2.列表List 3.集合Set 4.哈希Hash 5.Zset  ###mysql主从复制原理①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。 ②salve从库连接master主库，,Master有多少个slave就会创建多少个binlog dump线程。 ③当Master节点的binlog发生变化">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-f744dc30445c9b5b449f7f5f64f3fb4f_720w.webp">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-740d01e4bbc51036323c18a509070f42_720w.webp">
<meta property="article:published_time" content="2023-05-06T05:05:27.000Z">
<meta property="article:modified_time" content="2023-05-11T01:54:43.698Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-f744dc30445c9b5b449f7f5f64f3fb4f_720w.webp">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试题总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-05-06T05:05:27.000Z" itemprop="datePublished">2023-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试题总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="Redis五大基本数据类型"><a href="#Redis五大基本数据类型" class="headerlink" title="###Redis五大基本数据类型"></a>###Redis五大基本数据类型</h5><p>1.字符串</p>
<p>2.列表List</p>
<p>3.集合Set</p>
<p>4.哈希Hash</p>
<p>5.Zset</p>
<hr>
<h5 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="###mysql主从复制原理"></a>###mysql主从复制原理</h5><p>①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。</p>
<p>②salve从库连接master主库，,Master有多少个slave就会创建多少个binlog dump线程。</p>
<p>③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。</p>
<p>④I&#x2F;O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。</p>
<p>⑤SQL线程读取I&#x2F;O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。</p>
<hr>
<h5 id="mysql主从同步是怎么实现的"><a href="#mysql主从同步是怎么实现的" class="headerlink" title="###mysql主从同步是怎么实现的"></a>###mysql主从同步是怎么实现的</h5><p>通过二进制日志（Binary Log）实现。</p>
<p>1，当在主库上执行一条修改操作时，该操作会被写入二进制日志中。</p>
<p>2，从库会连接到主库，并请求要同步的数据副本。</p>
<p>3，<strong>从库发出的第一个请求是“dumping”</strong>，它请求主库将所有未同步的数据发送给从库。主库将符合条件的二进制日志文件和位置信息发送给从库。从库接收到这些信息后，会开始从主库复制数据，然后将其应用到自己的数据副本中，直到同步到最新位置。</p>
<p>在初始同步完成后，<strong>从库会根据主库上存储的二进制日志的更新来保持与主库同步。从库会定期向主库发送心跳包，以确保与主库的连接正常。</strong>如果从库检测到主库上有新的二进制日志，则会下载并解析这些日志，并将其中的内容应用到自己的数据副本中</p>
<hr>
<h5 id="nginx和apache的区别"><a href="#nginx和apache的区别" class="headerlink" title="###nginx和apache的区别"></a>###nginx和apache的区别</h5><ol>
<li><strong>apache 是同步多进程模型，一个连接对应一个进程</strong>，而 <strong>nginx 是异步的，多个连接（万级别）可以对应一个进程</strong><br>2.一般来说，<strong>需要性能的 web 服务，用 nginx</strong> 。如果<strong>不需要性能只求稳定，更考虑 apache</strong> ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多<br>Apache:<br>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache<br>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用<br>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。<br>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<p>Nginx:<br><strong>轻量级</strong>，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源<br><strong>抗并发</strong>，nginx 以 epoll and kqueue 作为开发模型，处理请求是<strong>异步非阻塞的</strong>，负载能力比 apache 高很多，而 apache 则是<strong>阻塞型</strong>的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，容易出现进程数飙升，拒绝服务的现象。<br>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上<br>nginx 的设计高度模块化，编写模块相对简单<br>nginx 作为负载均衡服务器，支持 7 层负载均衡<br>nginx 本身就是一个反向代理服务器，可以作为邮件代理服务器</p>
<hr>
<h5 id="请阐述-binlog-的三种日志格式？"><a href="#请阐述-binlog-的三种日志格式？" class="headerlink" title="###请阐述 binlog 的三种日志格式？"></a>###请阐述 binlog 的三种日志格式？</h5><p>ROW：日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改，只记录要修改的数据，只有value，不会有sql多表关联的情况</p>
<p>Statement：每一条会修改数据的sql都会记录在binlog中（Mysql默认是使用Statement日志格式）</p>
<p>MiXED：一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更（推荐使用MIXED）</p>
<hr>
<h5 id="MySQL-服务有哪些日志文件"><a href="#MySQL-服务有哪些日志文件" class="headerlink" title="###MySQL 服务有哪些日志文件"></a>###MySQL 服务有哪些日志文件</h5><p>错误日志、binlog 日志、查询日志、慢查询日志、事务日志、中继日志</p>
<hr>
<h5 id="下列与慢查询日志选项的作用？slow-query-log-，-slow-query-log-file，long-query-time"><a href="#下列与慢查询日志选项的作用？slow-query-log-，-slow-query-log-file，long-query-time" class="headerlink" title="###下列与慢查询日志选项的作用？slow-query-log ， slow-query-log-file，long-query-time"></a>###下列与慢查询日志选项的作用？slow-query-log ， slow-query-log-file，long-query-time</h5><p>slow-query-log 启用慢查询日志 </p>
<p>slow-query-log-file 定义慢查询日志名称 </p>
<p>long-query-time 指定超时时间</p>
<hr>
<h5 id="MySQL-数据库密码忘了怎么办？"><a href="#MySQL-数据库密码忘了怎么办？" class="headerlink" title="###MySQL 数据库密码忘了怎么办？"></a>###MySQL 数据库密码忘了怎么办？</h5><ol>
<li><p>停止 MySQL 服务程序 </p>
</li>
<li><p>跳过授权表启动 MySQL 服务程序 skip-grant-tables </p>
</li>
<li><p>重设 root 密码（更新 user 表记录） </p>
</li>
<li><p>以正常方式重启 MySQL 服务程序</p>
</li>
</ol>
<hr>
<h5 id="drop-delete和truncate区别"><a href="#drop-delete和truncate区别" class="headerlink" title="###drop,delete和truncate区别"></a>###drop,delete和truncate区别</h5><p>TRUNCATE 和 DELETE 只删除数据，而 DROP 则删除整个表（结构和数据）。</p>
<p>1）DELETE 删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p>
<p> 2）TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>3）表和索引所占空间。当表被 TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop 语句将表所占用的空间全释放掉。</p>
<hr>
<p>###数据库优化思路</p>
<hr>
<h5 id="了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"><a href="#了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？" class="headerlink" title="###了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"></a>###了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？</h5><p>慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。</p>
<p>相关参数：</p>
<ul>
<li>slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。</li>
<li>slow_query_log_file：MySQL数据库慢查询日志存储路径。</li>
<li>long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。</li>
<li>log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。</li>
<li>log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。</li>
</ul>
<p>如何对慢查询进行优化？</p>
<ul>
<li>分析语句的执行计划，查看SQL语句的索引是否命中</li>
<li>优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。</li>
<li>优化LIMIT分页。</li>
</ul>
<hr>
<h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="###常见状态码"></a>###常见状态码</h5><h5 id="1xx-临时响应-表示临时响应并需要请求者继续执行操作的状态代码"><a href="#1xx-临时响应-表示临时响应并需要请求者继续执行操作的状态代码" class="headerlink" title="1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码"></a>1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码</h5><p><strong>101 (切换协议)</strong> 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
<p><strong>201 (已创建)</strong> 请求成功并且服务器创建了新的资源。</p>
<h5 id="3xx-重定向-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a href="#3xx-重定向-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。" class="headerlink" title="3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。"></a>3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h5><p><strong>301 (永久移动)</strong> 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。<br><strong>302 (临时移动)</strong> 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h5 id="4xx-请求错误-这些状态代码表示请求可能出错，妨碍了服务器的处理"><a href="#4xx-请求错误-这些状态代码表示请求可能出错，妨碍了服务器的处理" class="headerlink" title="4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理"></a>4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理</h5><p><strong>400 (错误请求)</strong> 服务器不理解请求的语法。<br><strong>401 (未授权)</strong> 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br><strong>403 (禁止)</strong> 服务器拒绝请求。<br><strong>404 (未找到)</strong> 服务器找不到请求的网页</p>
<p><strong>405 (方法禁用)</strong> 禁用请求中指定的方法。</p>
<p><strong>408 (请求超时)</strong> 服务器等候请求时发生超时。</p>
<p>**5xx(服务器错误)**这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错</p>
<p>**500 (服务器内部错误) 服务器遇到错误，无法完成请求。<br>**501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>**502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。<br><strong>503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)</strong> 通常，这只是暂时状态。<br>**504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>**505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。</p>
<hr>
<h5 id="linux系统命令四剑客"><a href="#linux系统命令四剑客" class="headerlink" title="###linux系统命令四剑客"></a>###linux系统命令四剑客</h5><p>1、grep：用于查找文件中匹配的字符串。它可用于搜索单个文件或多个文件。grep命令的语法为：grep [选项][搜索文本] [文件名]。</p>
<p>2、awk：用于对文本进行处理和格式化。它可以对文本进行分割、过滤、排序等操作。awk命令的语法为：awk [选项][模式] [文件名]。</p>
<p>3、sed：用于对文本进行编辑和转换。它可以对文本进行替换、删除、插入等操作。sed命令的语法为：sed [选项][命令] [文件名]。</p>
<p>4、find：用于在文件系统中查找文件和目录。它可以按照不同的条件进行查找，如名称、大小、时间等。find命令的语法为：find [路径][选项] [表达式]。</p>
<hr>
<p>###linux如何对磁盘进行分区管理</p>
<hr>
<p>###数据库中的聚合函数</p>
<hr>
<h4 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="###OSI网络模型"></a>###OSI网络模型</h4><p><img src="https://pic4.zhimg.com/80/v2-f744dc30445c9b5b449f7f5f64f3fb4f_720w.webp" alt="img"></p>
<ul>
<li><strong>应用层</strong>：为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。</li>
<li><strong>表示层</strong>（PPDU）：处理数据的格式，处理数据加密和压缩。将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。</li>
<li><strong>会话层</strong>（SPDU）：负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</li>
<li><strong>传输层</strong>（TPDU）：起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。</li>
<li><strong>网络层</strong>（报文）：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。</li>
<li><strong>数据链路层</strong>（帧）：负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。建立和维护数据链路，提供物理地址（MAC地址）。</li>
<li><strong>物理层</strong>（比特）：负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。进行比特流的传输（比特流也是数据流，在不同的介质下表现的形式也不一样，在光纤中是光信号传递，这个比特流也就是光信号，如果是wifi，传递用的是光信号，那么比特流也就是光信号）</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-740d01e4bbc51036323c18a509070f42_720w.webp" alt="img"></p>
<hr>
<h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="###tcp和udp的区别"></a>###tcp和udp的区别</h3><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 是<strong>面向连接</strong>的、<strong>可靠</strong>的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP是面向<strong>面向字节流</strong>，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p>
<h5 id="TCP-为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。"><a href="#TCP-为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。" class="headerlink" title="TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。"></a>TCP 为提供可靠性传输，实行“<strong>顺序控制</strong>”或“<strong>重发控制</strong>”机制。此外还具备“<strong>流控制（流量控制）</strong>”、“<strong>拥塞控制</strong>”、提高网络利用率等众多功能。</h5><p>TCP有以下特点：</p>
<ul>
<li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>
<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>
<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ <strong>主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制</strong>等机制实现）。</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP <strong>面向报文</strong>，面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p>
<h5 id="UDP-是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成。在-UDP-的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。"><a href="#UDP-是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成。在-UDP-的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。" class="headerlink" title="UDP 是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。"></a>UDP 是<strong>不具有可靠性</strong>的数据报协议，细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</h5><p>UDP有以下特点：</p>
<ul>
<li><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</p>
</li>
<li><p>传输途中出现丢包，UDP 也不负责重发。</p>
</li>
<li><p>当包的到达顺序出现乱序时，UDP没有纠正的功能。</p>
</li>
<li><p>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</p>
</li>
<li><p>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</p>
</li>
<li><p>UDP 常用于以下几个方面：</p>
</li>
<li><ul>
<li>1.包总量较少的通信（DNS、SNMP等）；</li>
<li>2.视频、音频等多媒体通信（即时通信）；</li>
<li>3.限定于 LAN 等特定网络中的应用通信；</li>
<li>4.广播通信（广播、多播）</li>
</ul>
</li>
</ul>
<hr>
<p>###dns工作原理</p>
<h3 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="###三次握手建立连接"></a>###三次握手建立连接</h3><p><strong>第一次握手：</strong> 客户端发送syn包(seq&#x3D;x)到服务器，并进入SYN_SEND状态，等待服务器确认;</p>
<p><strong>第二次握手：</strong> 服务器收到syn包，必须确认客户的SYN(ack&#x3D;x+1)，同时自己也发送一个SYN包(seq&#x3D;y)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</p>
<p><strong>第三次握手</strong>：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p><strong>握手过程中传送的包里不包含数据</strong>，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。.</p>
<hr>
<h3 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="###四次挥手断开连接"></a>###四次挥手断开连接</h3><p><strong>第一次挥手：</strong> 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但此时主动关闭方还可以接受数据。</p>
<p><strong>第二次挥手</strong>：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)。</p>
<p><strong>第三次挥手：</strong> 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p><strong>第四次挥手：</strong> 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
<hr>
<h4 id="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="###为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a><strong>###为什么连接的时候是三次握手，关闭的时候却是四次挥手？</strong></h4><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>###http层的工作原理</p>
<p>###路由协议</p>
<p>###交换机的工作原理</p>
<p>###各个层的举例</p>
<p>###数据库备份和恢复的命令</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" data-id="clhii35kh0001kwaq7cqdb06t" data-title="面试题总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java面试题
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">java面试题</a>
          </li>
        
          <li>
            <a href="/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">面试题总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>