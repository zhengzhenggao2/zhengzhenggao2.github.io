<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-网络方向面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/11/%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-05-11T07:44:56.000Z" itemprop="datePublished">2023-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/11/%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/">网络方向面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="###OSI网络模型"></a>###OSI网络模型</h4><p><img src="https://pic4.zhimg.com/80/v2-f744dc30445c9b5b449f7f5f64f3fb4f_720w.webp" alt="img"></p>
<ul>
<li><strong>应用层</strong>：为应用程序提供服务并规定应用程序中通信相关的细节。包括HTTP、FTP、SMTP等协议。</li>
<li><strong>表示层</strong>（PPDU）：负责数据的格式转换和加密解密等。</li>
<li><strong>会话层</strong>（SPDU）：负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</li>
<li><strong>传输层</strong>（TPDU）：可靠传输的作用。负责端到端的数据传输，包括TCP和UDP协议。</li>
<li><strong>网络层</strong>（报文）：负责数据包的传输和路由选择，通常使用的协议有IP（网际协议）、ICMP（Internet控制消息协议）和ARP（地址解析协议）等</li>
<li><strong>数据链路层</strong>（帧）：负责建立和管理数据链路，通常使用的协议有PPP（点对点协议）、HDLC（高级数据链路控制）和MAC（媒体访问控制）</li>
<li><strong>物理层</strong>（比特）负责传输比特流，将数字信号转化为模拟信号，通常使用的协议有IEEE 802.3（以太网）和IEEE 802.11（无线局域网）等。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-740d01e4bbc51036323c18a509070f42_720w.webp" alt="img"></p>
<hr>
<h3 id="请简述TCP-x2F-IP协议的四层模型及其各自的功能。"><a href="#请简述TCP-x2F-IP协议的四层模型及其各自的功能。" class="headerlink" title="###请简述TCP&#x2F;IP协议的四层模型及其各自的功能。"></a>###请简述TCP&#x2F;IP协议的四层模型及其各自的功能。</h3><p>TCP&#x2F;IP协议的四层模型包括应用层、传输层、网络层和数据链路层。各自的功能如下：</p>
<ul>
<li>应用层：提供应用程序与网络通信的接口，包括HTTP、FTP、SMTP等协议。</li>
<li>传输层：负责数据传输，包括TCP和UDP协议。</li>
<li>网络层：负责数据在网络中的传输，包括IP协议。</li>
<li>数据链路层：负责数据在物理介质中的传输，包括以太网、WiFi等协议。</li>
</ul>
<hr>
<h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="###tcp和udp的区别"></a>###tcp和udp的区别</h3><p>答：TCP协议和UDP协议的区别如下：</p>
<ul>
<li>TCP协议提供可靠的数据传输，UDP协议不提供可靠的数据传输。</li>
<li>TCP协议需要建立连接，UDP协议不需要建立连接。</li>
<li>TCP协议提供流控制和拥塞控制，UDP协议不提供流控制和拥塞控制。</li>
<li>TCP协议适用于要求可靠传输的应用，UDP协议适用于实时传输的应用。</li>
</ul>
<hr>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 是<strong>面向连接</strong>的、<strong>可靠</strong>的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP是面向<strong>面向字节流</strong>，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p>
<h5 id="TCP-为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。"><a href="#TCP-为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。" class="headerlink" title="TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。"></a>TCP 为提供可靠性传输，实行“<strong>顺序控制</strong>”或“<strong>重发控制</strong>”机制。此外还具备“<strong>流控制（流量控制）</strong>”、“<strong>拥塞控制</strong>”、提高网络利用率等众多功能。</h5><p>TCP有以下特点：</p>
<ul>
<li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>
<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>
<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ <strong>主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制</strong>等机制实现）。</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP <strong>面向报文</strong>，面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p>
<h5 id="UDP-是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成。在-UDP-的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。"><a href="#UDP-是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成。在-UDP-的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。" class="headerlink" title="UDP 是不具有可靠性的数据报协议，细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。"></a>UDP 是<strong>不具有可靠性</strong>的数据报协议，细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</h5><p>UDP有以下特点：</p>
<ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li>
<li>传输途中出现丢包，UDP 也不负责重发。</li>
<li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li>
<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>
<li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li>
<li>UDP 常用于以下几个方面：</li>
<li><ul>
<li>1.包总量较少的通信（DNS、SNMP等）；</li>
<li>2.视频、音频等多媒体通信（即时通信）；</li>
<li>3.限定于 LAN 等特定网络中的应用通信；</li>
<li>4.广播通信（广播、多播）</li>
</ul>
</li>
</ul>
<h3 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="###三次握手建立连接"></a>###三次握手建立连接</h3><p><strong>第一次握手：</strong> 客户端发送syn包(seq&#x3D;x)到服务器，并进入SYN_SEND状态，等待服务器确认;</p>
<p><strong>第二次握手：</strong> 服务器收到syn包，必须确认客户的SYN(ack&#x3D;x+1)，同时自己也发送一个SYN包(seq&#x3D;y)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</p>
<p><strong>第三次握手</strong>：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p><strong>握手过程中传送的包里不包含数据</strong>，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。.</p>
<hr>
<h3 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="###四次挥手断开连接"></a>###四次挥手断开连接</h3><p><strong>第一次挥手：</strong> 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但此时主动关闭方还可以接受数据。</p>
<p><strong>第二次挥手</strong>：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)。</p>
<p><strong>第三次挥手：</strong> 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p><strong>第四次挥手：</strong> 主动关闭方收到FIN后，发送一个ACK给被动关闭方，并进入停止等待超时时间 （保证被动关闭方可以收到ack，如果没有收到则被动接收方重传fin包），被动关闭方ack收到后关闭链接。</p>
<hr>
<h4 id="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="###为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a><strong>###为什么连接的时候是三次握手，关闭的时候却是四次挥手？</strong></h4><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。为了解决网络信道不可靠的问题</p>
<p>但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。</p>
<hr>
<h4 id="为什么要三次握手，而不是两次握手服务端回复完SYN-ACK后就建立连接"><a href="#为什么要三次握手，而不是两次握手服务端回复完SYN-ACK后就建立连接" class="headerlink" title="###为什么要三次握手，而不是两次握手服务端回复完SYN+ACK后就建立连接"></a>###为什么要三次握手，而不是两次握手服务端回复完SYN+ACK后就建立连接</h4><p>**为了防止已失效的请求报文 突然又传到服务器引起错误 **</p>
<hr>
<h4 id="交换机工作原理（数据链路层）（二层设备）"><a href="#交换机工作原理（数据链路层）（二层设备）" class="headerlink" title="###交换机工作原理（数据链路层）（二层设备）"></a>###交换机工作原理（数据链路层）（二层设备）</h4><h5 id="交换机是一种用于局域网中的网络设备，主要用于实现局域网内计算机之间的通信。把数据包发送到正确的位置，交换机的工作原理如下："><a href="#交换机是一种用于局域网中的网络设备，主要用于实现局域网内计算机之间的通信。把数据包发送到正确的位置，交换机的工作原理如下：" class="headerlink" title="交换机是一种用于局域网中的网络设备，主要用于实现局域网内计算机之间的通信。把数据包发送到正确的位置，交换机的工作原理如下："></a>交换机是一种用于局域网中的网络设备，主要用于实现局域网内计算机之间的通信。把数据包发送到正确的位置，交换机的工作原理如下：</h5><p>数据帧的传输</p>
<p>当计算机发送数据时，数据会被封装成数据帧，并通过网卡发送到交换机。交换机会根据数据帧中的目的MAC地址，将数据帧发送到对应的端口，从而实现计算机之间的数据传输。</p>
<p>交换机工作原理如下：</p>
<ul>
<li>交换机在接收到数据帧以后，首先、会记录数据帧中的源 MAC 地址和对应的接口到 MAC 表中，接着、会检查自己的 MAC 表中是否有数据帧中目标 MAC 地址的信息，如果有则会根据 MAC 表中记录的对应接口将数据帧发送出去 (也就是单播)，如果没有，则会将该数据帧从非接受接口发送出去 (也就是广播，或者泛洪 Flood)。</li>
</ul>
<p>交换机的三个主要功能</p>
<ul>
<li>学习：以太网交换机了解每一端口相连设备的 MAC 地址，并将<strong>地址同相应的端口映射起来</strong>存放在交换机缓存中的 MAC 地址表中。</li>
<li>转发 &#x2F; 过滤：当一个数据帧的目的地址在 MAC 地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播 &#x2F; 组播帧则转发至所有端口)。</li>
<li>消除回路：当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后备路径。</li>
</ul>
<hr>
<h4 id="路由器工作原理（路由器工作于网络层）"><a href="#路由器工作原理（路由器工作于网络层）" class="headerlink" title="###路由器工作原理（路由器工作于网络层）"></a>###路由器工作原理（路由器工作于网络层）</h4><h5 id="主要用于实现不同网络之间的通信。路由器的工作原理如下："><a href="#主要用于实现不同网络之间的通信。路由器的工作原理如下：" class="headerlink" title="主要用于实现不同网络之间的通信。路由器的工作原理如下："></a>主要用于实现不同网络之间的通信。路由器的工作原理如下：</h5><ol>
<li>数据包的传输</li>
</ol>
<p>当计算机发送数据包时，数据包会通过网卡发送到路由器。路由器会根据数据包中的目的IP地址，将数据包发送到对应的下一跳路由器，从而实现不同网络之间的数据传输。</p>
<ol>
<li>路由表的维护</li>
</ol>
<p>路由器会维护一张路由表，用于记录不同网络的IP地址和对应的下一跳路由器。当路由器接收到一个数据包时，会根据路由表中的信息，将数据包发送到对应的下一跳路由器。</p>
<ol>
<li>路由选择协议</li>
</ol>
<p>路由器之间通过路由选择协议，如OSPF、BGP等，进行路由信息的交换和更新，从而保持路由表的正确性。路由选择协议会根据不同的算法，计算出到达目的网络的最优路径。</p>
<ol>
<li>NAT</li>
</ol>
<p>路由器还可以实现NAT（Network Address Translation），将内部网络的私有IP地址转换为公有IP地址，从而实现内部网络和互联网之间的通信。</p>
<p>总的来说，<strong>路由器的工作原理是通过路由表和路由选择协议，实现不同网络之间的数据传输。</strong>路由器可以提高网络的通信效率和安全性。</p>
<hr>
<h3 id="路由器与交换机的主要区别有六点："><a href="#路由器与交换机的主要区别有六点：" class="headerlink" title="###路由器与交换机的主要区别有六点："></a>###路由器与交换机的主要区别有六点：</h3><ul>
<li><p><strong>交换机</strong>工作于 TCP&#x2F;IP 协议的最后一层<strong>数据链路层（物理层）</strong>，<strong>路由器工作于网络层。</strong></p>
</li>
<li><p>路由器：寻址，转发（依靠 IP 地址），交换机：过滤，转发（依靠 MAC 地址）。路由器可以把一个 IP 分配给很多个主机使用，这些主机对外只表现出一个 IP，交换机可以把很多主机连起来，这些主机对外各有各的 IP。</p>
</li>
<li><p>交换机用于连接局域网，数据包在局域网内网的数据转发，路由器用于连接局域网和外网，数据包可以在不同局域网转发。</p>
</li>
<li><p>交换机负责具体的数据包传输，路由器不负责包的实际传输，路由器只封装好要传输的数据包，然后交给交换机去传输（不一定是交换机，可能是其他传输技术），用 java 比喻大概简单理解为路由器是抽象类，定义好传输的数据包格式，交换机是具体实现类，也可以有其他实现类</p>
</li>
<li><p>交换机没有 MAC 地址和 IP 地址，路由器有 MAC 地址和 IP 地址（指纯碎的交换机和路由器，三层交换机是可以有 IP 地址的，路由器也有内置交换机功能的）</p>
</li>
<li><p>路由器提供了防火墙的服务，交换机不能提供该功能。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p>
</li>
</ul>
<hr>
<h4 id="常见路由协议以及特点"><a href="#常见路由协议以及特点" class="headerlink" title="###常见路由协议以及特点"></a>###常见路由协议以及特点</h4><ol>
<li>静态路由（Static Routing）：管理员手动配置路由表，不需要协议进行路由选择，适用于网络规模较小或者网络结构比较简单的情况。静态路由的优点是简单、稳定，缺点是路由表需要手动配置，管理成本较高，不适合大型复杂网络。</li>
<li>RIP（Routing Information Protocol）：是一种基于距离向量（Distance Vector）的路由协议，使用Hop Count作为衡量距离的度量标准，最多支持15跳，适用于小型网络环境。RIP的优点是简单易用，缺点是收敛速度慢，容易产生路由环路。</li>
<li>OSPF（Open Shortest Path First）：是一种链路状态（Link State）的路由协议，使用Link State Advertisement（LSA）来描述网络拓扑结构，通过Dijkstra算法计算最短路径，适用于大型复杂网络。OSPF的优点是收敛速度快、灵活性好，缺点是协议复杂，占用资源高。</li>
<li>BGP（Border Gateway Protocol）：是一种广域网（WAN）协议，主要用于互联网核心路由器之间的路由交换，使用Path Vector算法来选择最佳路径，适用于大型ISP级网络。BGP的优点是可扩展性好，支持多种路由选择策略，缺点是配置复杂、路由策略易被攻击。</li>
<li>IS-IS（Intermediate System to Intermediate System）是一种自治系统内部网关协议（IGP），与OSPF一样属于链路状态（Link-State）路由协议。IS-IS最初是由DEC（Digital Equipment Corporation）开发的，现在已成为ISO（国际标准化组织）的标准协议之一，可以用于IP、IPX、ATM等多种协议的路由。</li>
</ol>
<hr>
<h3 id="http层的工作原理"><a href="#http层的工作原理" class="headerlink" title="###http层的工作原理"></a>###http层的工作原理</h3><p>答：HTTP协议的工作原理如下：</p>
<p>1）客户端向服务器发送HTTP请求。</p>
<p>2）服务器收到请求后，返回HTTP响应。</p>
<p>3）客户端收到响应后，解析响应中的HTML、CSS、JavaScript等资源，并在浏览器中渲染页面。</p>
<hr>
<h3 id="dns域名解析过程"><a href="#dns域名解析过程" class="headerlink" title="###dns域名解析过程"></a>###dns域名解析过程</h3><p>1）客户端向本地DNS服务器发送域名解析请求。</p>
<p>2）本地DNS服务器收到请求后，先查询本地缓存是否有对应的IP地址。</p>
<p>3）如果本地缓存中没有对应的IP地址，则向根DNS服务器发送请求。</p>
<p>4）根DNS服务器返回对应顶级域名服务器的IP地址。</p>
<p>5）本地DNS服务器向顶级域名服务器发送请求。</p>
<p>6）顶级域名服务器返回下一级域名服务器的IP地址。</p>
<p>7）本地DNS服务器向下一级域名服务器发送请求。</p>
<p>8）下一级域名服务器返回对应主机的IP地址。</p>
<p>9）本地DNS服务器将IP地址返回给客户端。</p>
<hr>
<h3 id="子网划分和网关是什么"><a href="#子网划分和网关是什么" class="headerlink" title="###子网划分和网关是什么"></a>###子网划分和网关是什么</h3><p><img src="https://img-blog.csdnimg.cn/da1048ef7f794a7dbb94aaab8daa5149.png" alt="在这里插入图片描述"></p>
<p>网关就是要去别的网络的时候，把报文首先发送到的那台设备（网间连接器、协议转换器）</p>
<p>tcp&#x2F;ip协议规定不同子网之间不能直接通信，如果要通信 则要通过网关</p>
<p><img src="https://img-blog.csdnimg.cn/1c37dff690094f19a390b28c856cd86b.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="###网络拓扑结构"></a>###网络拓扑结构</h3><ol>
<li><p>星型拓扑结构（Star Topology）：所有的节点都通过一个集线器或交换机连接在一起，节点之间直接不互相连接，只能通过中心设备进行通信。</p>
</li>
<li><p>总线拓扑结构（Bus Topology）：所有的节点都连接在一条主线上，节点之间可以直接通信，但是当主线发生故障时，整个网络将无法运行。</p>
</li>
<li><p>环形拓扑结构（Ring Topology）：所有的节点都连接在一个环形的链路上，节点之间可以直接通信，但是当其中一个节点发生故障时，整个网络将无法运行。</p>
</li>
<li><p>树形拓扑结构（Tree Topology）：所有的节点按照树形结构连接在一起，节点之间可以有多个路径通信，但是当根节点发生故障时，整个网络将无法运行。</p>
</li>
<li><p>网状拓扑结构（Mesh Topology）：所有的节点之间都直接连接，节点之间可以通过多个路径通信，具有高度的容错性，但是节点之间的连接复杂，需要占用大量的资源。</p>
</li>
<li><p>混合拓扑结构（Hybrid Topology）：将多种拓扑结构组合在一起，形成一种混合结构。在实际应用中，混合拓扑结构是最为常见的一种结构。不同的拓扑结构具有不同的优缺点，需要根据实际需求来选择合适的拓扑结构。</p>
<hr>
</li>
</ol>
<h2 id="路由协议"><a href="#路由协议" class="headerlink" title="###路由协议"></a>###路由协议</h2><ol>
<li>静态路由（Static Routing）：管理员手动配置路由表，不需要协议进行路由选择，适用于网络规模较小或者网络结构比较简单的情况。静态路由的优点是简单、稳定，缺点是路由表需要手动配置，管理成本较高，不适合大型复杂网络。</li>
<li>RIP（Routing Information Protocol）：是一种基于距离向量（Distance Vector）的路由协议，使用Hop Count作为衡量距离的度量标准，最多支持15跳，适用于小型网络环境。RIP的优点是简单易用，缺点是收敛速度慢，容易产生路由环路。</li>
<li>OSPF（Open Shortest Path First）：是一种链路状态（Link State）的路由协议，使用Link State Advertisement（LSA）来描述网络拓扑结构，通过Dijkstra算法计算最短路径，适用于大型复杂网络。OSPF的优点是收敛速度快、灵活性好，缺点是协议复杂，占用资源高。</li>
<li>BGP（Border Gateway Protocol）：是一种广域网（WAN）协议，主要用于互联网核心路由器之间的路由交换，使用Path Vector算法来选择最佳路径，适用于大型ISP级网络。BGP的优点是可扩展性好，支持多种路由选择策略，缺点是配置复杂、路由策略易被攻击。</li>
<li>IS-IS（Intermediate System to Intermediate System）是一种自治系统内部网关协议（IGP），与OSPF一样属于链路状态（Link-State）路由协议。IS-IS最初是由DEC（Digital Equipment Corporation）开发的，现在已成为ISO（国际标准化组织）的标准协议之一，可以用于IP、IPX、ATM等多种协议的路由。</li>
</ol>
<h4 id="三层交换机和二层交换机的区别，三层交换机与路由器区别"><a href="#三层交换机和二层交换机的区别，三层交换机与路由器区别" class="headerlink" title="###三层交换机和二层交换机的区别，三层交换机与路由器区别"></a>###<strong>三层交换机和二层交换机的区别，三层交换机与路由器区别</strong></h4><p><strong>二层交换机</strong>（在osi二层）属数据链路层设备，可以识别数据包中的 MAC地址信息， 根据MAC地址进行转发， 并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。<strong>只能给一个vlan配置三层地址</strong></p>
<p><strong>三层交换机</strong> ：具有部分路由器功能的交换机，工作在osi标准模型的 第三层网络层。可以加快大型局域网内部的数据转换，能做到一次路由多次转发。<strong>可以给多个vlan配置三层地址</strong></p>
<p>三层交换技术就是将<strong>路由技术</strong>与<strong>交换技术合</strong>二为一的技术。在对第一个数据流进行路由后，它将会产生一个MAC地址与IP地址的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过而不是再次路由，从而消除了路由器进行路由选择而造成网络的延迟，提高了数据包转发的效率。（mac地址交换效率高于ip地址交换）</p>
<p>二层交换机和三层交换机的区别：</p>
<p>​         三层交换机使用了三层交换技术</p>
<p>​         简单地说，三层交换技术就是：二层交换技术＋三层转发技术。它解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。</p>
<h5 id="什么是三层交换"><a href="#什么是三层交换" class="headerlink" title="什么是三层交换"></a>什么是三层交换</h5><p>​        三层交换（也称多层交换技术，或IP交换技术）是相对于传统交换概念而提出的。传统的交换技术是在OSI网络标准模型中的第二层——<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&spm=1001.2101.3001.7020">数据链路层</a>进行作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。简单地说，三层交换技术就是：二层交换技术＋三层转发技术。</p>
<p>​         三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。</p>
<h5 id="第二层交换机和路由器的区别："><a href="#第二层交换机和路由器的区别：" class="headerlink" title="第二层交换机和路由器的区别："></a>第二层交换机和路由器的区别：</h5><p>​        传统交换机从网桥发展而来，属于OSI第二层即数据链路层设备。它根据MAC地址寻址，通过站表选择路由，站表的建立和维护由交换机自动进行。路由器属于OSI第三层即网络层设备，它根据IP地址进行寻址，通过路由表路由协议产生。交换机最大的好处是快速，由于交换机只须识别帧中MAC地址，直接根据MAC地址产生选择转发端口算法简单，便于ASIC实现，因此转发速度极高</p>
<h5 id="第三层交换机与传统路由器相比有如下优点："><a href="#第三层交换机与传统路由器相比有如下优点：" class="headerlink" title="第三层交换机与传统路由器相比有如下优点："></a>第三层交换机与传统路由器相比有如下优点：</h5><p>1，子网间传输带宽可任意分配：传统路由器每个接口连接一个子网，子网通过路由器进行传输的速率被接口的带宽所限制。而三层交换机则不同，它可以把多个端口定义成一个虚拟网，把多个端口组成的虚拟网作为虚拟网接口，该虚拟网内信息可通过组成虚拟网的端口送给三层交换机，由于端口数可任意指定，子网间传输带宽没有限制</p>
<p>2，降低成本：通常的网络设计用交换机构成子网，用路由器进行子网间互连。目前采用三层交换机进行网络设计，既可以进行任意虚拟子网划分，又可以通过交换机三层路由功能完成子网间通信，为此节省了价格昂贵的路由器。</p>
<p>###数据库备份和恢复的命令</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/11/%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clhj91fh70002ecaqc3pd4y8t" data-title="网络方向面试题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-05-10T06:30:30.000Z" itemprop="datePublished">2023-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">java面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>###<strong>JVM、JRE和JDK的关系是什么</strong></p>
<p>JDK是（Java Development Kit）的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE是Java Runtime Environment缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>JDK包含JRE，JRE包含JVM。</p>
<hr>
<p>###<strong>什么是字节码?采用字节码的好处是什么?</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clhj91fgy0000ecaq6swfcvuz" data-title="java面试题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试题总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-05-06T05:05:27.000Z" itemprop="datePublished">2023-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">linux面试题总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="Redis五大基本数据类型"><a href="#Redis五大基本数据类型" class="headerlink" title="###Redis五大基本数据类型"></a>###Redis五大基本数据类型</h5><p>1.字符串</p>
<p>2.列表List</p>
<p>3.集合Set</p>
<p>4.哈希Hash</p>
<p>5.Zset</p>
<hr>
<h5 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="###mysql主从复制原理"></a>###mysql主从复制原理</h5><p>①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。</p>
<p>②salve从库连接master主库，,Master有多少个slave就会创建多少个binlog dump线程。</p>
<p>③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。</p>
<p>④I&#x2F;O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。</p>
<p>⑤SQL线程读取I&#x2F;O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。</p>
<hr>
<h5 id="mysql主从同步是怎么实现的"><a href="#mysql主从同步是怎么实现的" class="headerlink" title="###mysql主从同步是怎么实现的"></a>###mysql主从同步是怎么实现的</h5><p>通过二进制日志（Binary Log）实现。</p>
<p>1，当在主库上执行一条修改操作时，该操作会被写入二进制日志中。</p>
<p>2，从库会连接到主库，并请求要同步的数据副本。</p>
<p>3，<strong>从库发出的第一个请求是“dumping”</strong>，它请求主库将所有未同步的数据发送给从库。主库将符合条件的二进制日志文件和位置信息发送给从库。从库接收到这些信息后，会开始从主库复制数据，然后将其应用到自己的数据副本中，直到同步到最新位置。</p>
<p>在初始同步完成后，<strong>从库会根据主库上存储的二进制日志的更新来保持与主库同步。从库会定期向主库发送心跳包，以确保与主库的连接正常。</strong>如果从库检测到主库上有新的二进制日志，则会下载并解析这些日志，并将其中的内容应用到自己的数据副本中</p>
<hr>
<h5 id="nginx和apache的区别"><a href="#nginx和apache的区别" class="headerlink" title="###nginx和apache的区别"></a>###nginx和apache的区别</h5><ol>
<li><strong>apache 是同步多进程模型，一个连接对应一个进程</strong>，而 <strong>nginx 是异步的，多个连接（万级别）可以对应一个进程</strong><br>2.一般来说，<strong>需要性能的 web 服务，用 nginx</strong> 。如果<strong>不需要性能只求稳定，更考虑 apache</strong> ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多<br>Apache:<br>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache<br>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用<br>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。<br>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<p>Nginx:<br><strong>轻量级</strong>，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源<br><strong>抗并发</strong>，nginx 以 epoll and kqueue 作为开发模型，处理请求是<strong>异步非阻塞的</strong>，负载能力比 apache 高很多，而 apache 则是<strong>阻塞型</strong>的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，容易出现进程数飙升，拒绝服务的现象。<br>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上<br>nginx 的设计高度模块化，编写模块相对简单<br>nginx 作为负载均衡服务器，支持 7 层负载均衡<br>nginx 本身就是一个反向代理服务器，可以作为邮件代理服务器</p>
<hr>
<h5 id="请阐述-binlog-的三种日志格式？"><a href="#请阐述-binlog-的三种日志格式？" class="headerlink" title="###请阐述 binlog 的三种日志格式？"></a>###请阐述 binlog 的三种日志格式？</h5><p>ROW：日志中会记录成每一行数据被修改的形式，然后在slave端再对相同的数据进行修改，只记录要修改的数据，只有value，不会有sql多表关联的情况</p>
<p>Statement：每一条会修改数据的sql都会记录在binlog中（Mysql默认是使用Statement日志格式）</p>
<p>MiXED：一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更（推荐使用MIXED）</p>
<hr>
<h5 id="MySQL-服务有哪些日志文件"><a href="#MySQL-服务有哪些日志文件" class="headerlink" title="###MySQL 服务有哪些日志文件"></a>###MySQL 服务有哪些日志文件</h5><p>错误日志、binlog 日志、查询日志、慢查询日志、事务日志、中继日志</p>
<hr>
<h5 id="下列与慢查询日志选项的作用？slow-query-log-，-slow-query-log-file，long-query-time"><a href="#下列与慢查询日志选项的作用？slow-query-log-，-slow-query-log-file，long-query-time" class="headerlink" title="###下列与慢查询日志选项的作用？slow-query-log ， slow-query-log-file，long-query-time"></a>###下列与慢查询日志选项的作用？slow-query-log ， slow-query-log-file，long-query-time</h5><p>slow-query-log 启用慢查询日志 </p>
<p>slow-query-log-file 定义慢查询日志名称 </p>
<p>long-query-time 指定超时时间</p>
<hr>
<h5 id="MySQL-数据库密码忘了怎么办？"><a href="#MySQL-数据库密码忘了怎么办？" class="headerlink" title="###MySQL 数据库密码忘了怎么办？"></a>###MySQL 数据库密码忘了怎么办？</h5><ol>
<li><p>停止 MySQL 服务程序 </p>
</li>
<li><p>跳过授权表启动 MySQL 服务程序 skip-grant-tables </p>
</li>
<li><p>重设 root 密码（更新 user 表记录） </p>
</li>
<li><p>以正常方式重启 MySQL 服务程序</p>
</li>
</ol>
<hr>
<h5 id="drop-delete和truncate区别"><a href="#drop-delete和truncate区别" class="headerlink" title="###drop,delete和truncate区别"></a>###drop,delete和truncate区别</h5><p>TRUNCATE 和 DELETE 只删除数据，而 DROP 则删除整个表（结构和数据）。</p>
<p>1）DELETE 删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p>
<p> 2）TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>3）表和索引所占空间。当表被 TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop 语句将表所占用的空间全释放掉。</p>
<hr>
<p>###数据库优化思路</p>
<hr>
<h5 id="了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"><a href="#了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？" class="headerlink" title="###了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？"></a>###了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？</h5><p>慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。</p>
<p>相关参数：</p>
<ul>
<li>slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。</li>
<li>slow_query_log_file：MySQL数据库慢查询日志存储路径。</li>
<li>long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。</li>
<li>log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。</li>
<li>log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。</li>
</ul>
<p>如何对慢查询进行优化？</p>
<ul>
<li>分析语句的执行计划，查看SQL语句的索引是否命中</li>
<li>优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。</li>
<li>优化LIMIT分页。</li>
</ul>
<hr>
<h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="###常见状态码"></a>###常见状态码</h5><h5 id="1xx-临时响应-表示临时响应并需要请求者继续执行操作的状态代码"><a href="#1xx-临时响应-表示临时响应并需要请求者继续执行操作的状态代码" class="headerlink" title="1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码"></a>1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码</h5><p><strong>101 (切换协议)</strong> 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
<p><strong>201 (已创建)</strong> 请求成功并且服务器创建了新的资源。</p>
<h5 id="3xx-重定向-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a href="#3xx-重定向-表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。" class="headerlink" title="3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。"></a>3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h5><p><strong>301 (永久移动)</strong> 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。<br><strong>302 (临时移动)</strong> 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h5 id="4xx-请求错误-这些状态代码表示请求可能出错，妨碍了服务器的处理"><a href="#4xx-请求错误-这些状态代码表示请求可能出错，妨碍了服务器的处理" class="headerlink" title="4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理"></a>4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理</h5><p><strong>400 (错误请求)</strong> 服务器不理解请求的语法。<br><strong>401 (未授权)</strong> 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br><strong>403 (禁止)</strong> 服务器拒绝请求。<br><strong>404 (未找到)</strong> 服务器找不到请求的网页</p>
<p><strong>405 (方法禁用)</strong> 禁用请求中指定的方法。</p>
<p><strong>408 (请求超时)</strong> 服务器等候请求时发生超时。</p>
<p>**5xx(服务器错误)**这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错</p>
<p>**500 (服务器内部错误) 服务器遇到错误，无法完成请求。<br>**501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>**502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。<br><strong>503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)</strong> 通常，这只是暂时状态。<br>**504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>**505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。</p>
<hr>
<h5 id="linux系统命令四剑客"><a href="#linux系统命令四剑客" class="headerlink" title="###linux系统命令四剑客"></a>###linux系统命令四剑客</h5><p>1、grep：用于查找文件中匹配的字符串。它可用于搜索单个文件或多个文件。grep命令的语法为：grep [选项][搜索文本] [文件名]。</p>
<p>2、awk：用于对文本进行处理和格式化。它可以对文本进行分割、过滤、排序等操作。awk命令的语法为：awk [选项][模式] [文件名]。</p>
<p>3、sed：用于对文本进行编辑和转换。它可以对文本进行替换、删除、插入等操作。sed命令的语法为：sed [选项][命令] [文件名]。</p>
<p>4、find：用于在文件系统中查找文件和目录。它可以按照不同的条件进行查找，如名称、大小、时间等。find命令的语法为：find [路径][选项] [表达式]。</p>
<hr>
<p>###linux如何对磁盘进行分区管理</p>
<hr>
<p>###数据库中的聚合函数</p>
<hr>
<p>###常见命令</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" data-id="clhj91fh40001ecaq4xqcc9mp" data-title="linux面试题总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/11/%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/">网络方向面试题</a>
          </li>
        
          <li>
            <a href="/2023/05/10/java%E9%9D%A2%E8%AF%95%E9%A2%98/">java面试题</a>
          </li>
        
          <li>
            <a href="/2023/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">linux面试题总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>